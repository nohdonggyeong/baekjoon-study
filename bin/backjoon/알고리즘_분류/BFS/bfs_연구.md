## 너비 우선 탐색(BFS)
- 2차원 배열의 미로에서 최단 거리를 구할 때 사용한다.
- 모든 경우의 수를 다 찾아내는 dfs와는 대조적으로 최단 거리를 구하기 위해 반복 중간에 목표 값이 나오면 그 시점의 최소 값을 반환하는 구조이다.
- 미로라고 하여 막다른 길을 만나 다시 돌아가는 상황이 있다 하더라도 bfs 방법에 별다른 처리를 하지 않아도 된다. 왜냐하면 막힌 길이라면 가능한 방향들을 추가시켜주는 if문을 타지 않고 그대로 해당 경우가 소멸되며, 그 전의 방향이 여러 개였던 지점에서 다음 경로 탐색을 계속 할 것이기 때문이다.z
- int N, int M, int[N][M] maze, boolean[N][M] visited, int[4] dx {-1, 1, 0, 0}, int[4] dy {0, 0, -1, 1}을 보통 선언하고 시작한다.
- class Node로 x, y, minCnt를 관리하고, NoArgsConstructor, 그 외 필요한 생성자를 활용한다.
- Queue<Node> commandQueue = new LinkedList<>();로 명령을 적재시킨다는 개념으로 가능한 방향들을 while 문 안에서 추가시켜준다.
- 목적지 도달하는 최단 경로는 while문 안의 각 방향의 if문에서 cnt + 1로 최신화시켜주면 된다. 각 경로마다의 시간이 cnt이고, 너비 우선 탐색으로 최단 거리를 찾기 때문.
- dfs와 비슷하게 풀기 가능한 타일의 개수를 구하는 것은 max = 0, max++로 풀어야 하고 위의 내용처럼 while문 안의 각 방향의 if문에서 cnt + 1로 최신화하면 안됨.
- bfs 최종 경로를 역추적 하기 위해 String[][] history를 boolean[][] visited와 함께 선언하고, 매번 visited = true 처리할 때마다 같은 인덱스의 history에 Node경로정보 String을 쌓아가고 최종 출력할 것.
- 또는 String[][] history를 boolean visited와 함께 선언하고, history의 값을 부모 값으로 담아두고 최종 조건에서 역으로 반복문을 돌려 출력할 것.