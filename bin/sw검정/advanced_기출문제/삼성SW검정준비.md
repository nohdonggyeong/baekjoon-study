## 보통 2차원 배열을 이용한 구현 문제(완전 탐색, 시뮬레이션)가 나옵니다.
<hr>

#### * 속도 비교하면 Array 사용하여 시간복잡도 줄일 것: Array(미리 할당해서 조회 빠르지만 추가, 삭제 어려움), ArrayList(Array와 List를 절충하여 약간 느림), List(추가, 삭제가 편리하지만 조회 느림)

  * 완전 탐색
    - 브루트 포스
    - 비트 마스크
    - 순열
    - 백 트래킹
    - 너비 우선 탐색
    - 깊이 우선 탐색
  
  * 시뮬레이션
  
<hr>
 
 1. 구현 문제(Implementation): 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
 2. 완전 탐색(Exhaustive Search): 모든 경우의 수를 주저 없이 다 계산하는 방법
 3. 시뮬레이션(Simulation): 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법
 4. 브루트 포스(Brute Force): 조건문(if)과 반복문(for, while)으로 모든 경우의 수를 대입하여 자원만 충분하다면 원하는 값을 100% 확률로 찾는 방법. 브루트포스보다 BFS, 백트래킹 더 짧은 시간이 소요됨
 5. 비트 마스크(Bit Mask) : 정수의 이진수 표현법을 사용하는 방법으로 큰 속도 향상을 가져올 수 있으며 집합 구현에 자주 사용함
 6. 너비 우선 탐색(BFS): 최단 경로를 구하기 위해 정점과 같은 레벨에 있는 형제 노드부터 탐색하는 방법
 7. 깊이 우선 탐색(DFS): 모든 경로의 수를 구하기 위해 정점의 자식 노드부터 탐색하는 방법
 8. 백 트래킹(Back Tracking): 트리 형태의 노드들을 깊이 우선 탐색(DFS)을 수행하면서, 노드의 유망성을 판단하여, 유망하지 못하다고 생각하면 가지치기를 하고(풀이시간 단축), 다시 부모 노드로 돌아가서 다른 자식 노드를 탐색하는 방식
 9. 순열(Permutation) : 서로 다른 N개에서 r개를 뽑아 한 줄로 세우는 경우의 수를 찾는 방법으로 백 트래킹(DFS) 방법 사용